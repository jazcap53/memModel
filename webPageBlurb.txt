<p>
A three-week release cycle has been introduced for this program as part of an experiment in Agile methodology.
</p>
<p>
MemModel simulates a hard disk, memory, and page table system, with journaling, program status recording, and disk error detection in the case of a crash. It also implements a file system, and a dedicated client class. Conceptually, a file is (at present) simply an association between an inode and an identifier. An inode table and a free list support this construct. 
</p>
<p>
An ArrBit class is among the new features in this version. It is an array<> of bitset<>'s that presents a bitset interface to the user. It replaces a simple bitset in places where the limit on the size of the standard library container (about 2^20 bits on my machine) would constrain the scalability of the system.
</p>
<p>
Also new is the WipeList class. This tracks which blocks have been assigned to a file, written to, and then returned to the system. It ensures, using a lazy strategy, that such blocks are clean before they are assigned to a new file.
</p>
<p>
MemModel's inodes are similar to UNIX inodes; an ArrBit instance tracks which nodes are available. The free list (of disk blocks) is maintained as a pair of ArrBit's. Both the free list and the inode table are persisted as binary files.
</p>
<p>
The FileShifter class allows certain system-maintained files to be updated in a manner that makes it impossible for an incomplete file to be accessed.
</p>
<p>
A file manager class provides the sole interface between the client and the rest of the system. The client makes requests of the file manager to create or delete files, to allocate or deallocate blocks to/from a file, and to read or write blocks. The file manager fulfills most of these requests itself, but passes read and write requests to the memory manager.
</p>
<p>
The memory manager obeys commands to read and write disk blocks, first copying the blocks into memory if necessary. A page table, maintained as a min-heap, tracks which blocks are present in memory, and when they were last accessed. When memory is full, and a block is needed which is not in memory, the manager evicts the Least Recently Used page and brings in the targeted block.
</p>
<p>
Dirty pages are implemented via a container class; each container instance holds only the altered lines for a single page. At regular intervals, changes are written to a journal. At longer intervals, and on shutdown, the journal is purged to the simulated disk using an elevator algorithm. The journal and simulated disk are implemented as binary files; the journal file is maintained as a circular buffer.
</p>
<p>
The program records its status by writing its last action completed to file. In the case of a pull-plug-from-wall type event, MemModel will recover any journaled data that has not yet been written to file. A Cyclic Redundancy Check (CRC, via Boost*) is performed on the simulated disk at program startup and on shutdown. The CRC notes any corrupted disk blocks.
</p>
<p>
MemModel is written in C++. Its activity can be traced via messages sent to clog; a sample output file is provided. The scale of the project has been kept very small, for the time being, so that the output files will be short.
</p>
